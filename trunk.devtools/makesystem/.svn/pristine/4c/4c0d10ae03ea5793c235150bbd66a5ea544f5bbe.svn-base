#!/usr/bin/env python2

# Copyright (c) 2008-2013 Motorola Mobility, Inc. All rights reserved.
# Copyright (c) 2013-2015 ARRIS Enterprises, Inc. All rights reserved.
#
# This program is confidential and proprietary to ARRIS Enterprises, Inc.
# (ARRIS), and may not be copied, reproduced, modified, disclosed to others,
# published or used, in whole or in part, without the express prior written
# permission of ARRIS.

import re
import os
import sys
import time


# See common/3pp/gtest/patches/support_more_mock_method_arguments.patch in bsg.
MAX_METHOD_ARGUMENTS = 20


class MockError(Exception):
    pass


class MockGenerator:
    def __init__(self, h_type, interface_path, interface_file, dist_path,
                 h_file, cpp_file, target_h_file, dependency_file):
        h_fp = open(h_file, "w")
        cpp_fp = open(cpp_file, "w")
        dep_fp = open(dependency_file, "w")
        self.h_type = h_type
        self.interface_path = interface_path
        self.interface_file = interface_file
        self.indenter = Indenter(h_fp)
        self.cpp_indenter = Indenter(cpp_fp)
        self.dist_path = dist_path
        self.namespaces = []  # stack of namespaces and class names
        self.destructor_throw_clauses = []  # stack
        self.base_class_headers = set()
        self.base_class_headers.add("./" + interface_file)

        # Signatures of methods generated so far for the current class
        self.generated_methods_for_class = set()

        # virtual <return type> <method name> (<arguments>) [qualifier] = 0;
        function_re = (
            r"(?P<returnType>[^()]+?)\s+(?P<name>\w+)\s*"
            r"\((?P<arguments>.*?)\)\s*"
            r"(?P<qualifiers>"
            r"  (?:"
            r"    const\s* | throw\s*\([^)]*\)\s*"
            r"  )*"
            r")")
        self.method_re = re.compile(
            r"(?x)"
            r"^\s*virtual\s+"
            + function_re +
            r"\s*=\s*0\s*;")
        self.concrete_method_re = re.compile(
            r"(?x)"
            r"^\s*(?:virtual\s+)?"
            + function_re +
            r"\s*(?:;|$)")

        # [virtual] ~...(...) [throw (...)] [= 0];
        self.destructor_re = re.compile(
            r"^\s*(?:virtual)?\s*~\w+\s*\(.*?\)(?P<throw>\s*throw"
            r"\s*\([^)]*\))?\s*(?:$|=\s*0|;)")

        # class <interface> [: public [virtual] <interface> [,] ]
        self.class_re = re.compile(r"^\s*class\s+(?:(?:EXPORT|LOCAL)\s+)?"
                                   r"[IT](?P<class>\w+)\s*(:|$)")
        self.class_re2 = re.compile(
            r"\s*public(?:\s+virtual)?\s+([IT]\w+),?\s*")

        try:
            (self.class_prefix, self.class_name) = \
                re.match(r".*?/?([IT])([A-Z]\w+)\.h", interface_file).groups()
        except:
            raise MockError("File name does not have interface format: "
                            + interface_file)

        self.begin_header()
        self.generate_interface(interface_file, None)
        self.end_header()

        self.generate_dependencies(dep_fp, target_h_file)
        h_fp.close()
        cpp_fp.close()
        dep_fp.close()

    def generate_dependencies(self, dependency_file, header_file):
        # generate dependencies for mock header file
        s = header_file + ": " + " ".join(self.base_class_headers) + "\n"
        # generate phony targets for dependencies.
        for e in self.base_class_headers:
            s += e + ":\n"
        dependency_file.write(s)

    def find_include_file_for_class(self, includes, name):
        files_to_search = [os.path.join(x, y)
                           for x in [".", self.dist_path]
                           for y in includes]
        for inc_file in files_to_search:
            if os.path.exists(inc_file):
                if re.match(r"(?s).*\sclass\s+(?:(?:EXPORT|LOCAL)\s+)?"
                            r"{0}\W".format(name),
                            open(inc_file).read()):
                    return inc_file
        raise MockError(
            "Could not find header file for base class {0} (searched "
            " {1})".format(name, ", ".join(repr(x) for x in files_to_search)))

    def begin_header(self):
        if self.h_type == "local":
            interface_file_include = self.interface_file
        else:
            interface_file_include = "{0}/{1}".format(
                self.interface_path,
                os.path.basename(self.interface_file))
        header = """\
// Copyright (c) %s ARRIS Enterprises, Inc. All rights reserved.
//
// This program is confidential and proprietary to ARRIS Enterprises, Inc.
// (ARRIS), and may not be copied, reproduced, modified, disclosed to others,
// published or used, in whole or in part, without the express prior written
// permission of ARRIS.
//
// This file was generated by createmock from %s.
//
// DO NOT EDIT, CHANGES WILL BE LOST!
""" % (time.strftime("%Y"), self.interface_file)
        self.indenter.write(header)
        self.indenter.write("""\
#ifndef {p}_MOCKS_TMOCK{c}_H
#define {p}_MOCKS_TMOCK{c}_H

#include "{i}"
#include <gmock/gmock.h>
""".format(p=re.sub(r"[./+-]", "_", self.interface_path.upper()),
           c=self.class_name.upper(),
           i=interface_file_include))

        self.cpp_indenter.write(header)
        self.cpp_indenter.write(
            '#include "TMock{0}.h"'.format(self.class_name))

    def end_header(self):
        self.indenter.write("#endif")

    def begin_class(self, class_name):
        self.namespaces.append("TNaggyMock%s" % class_name)
        self.destructor_throw_clauses.append("")
        self.indenter.write("""\
class TNaggyMock{n} : public {p}{n}
{{
public:""".format(n=class_name, p=self.class_prefix))
        self.indenter.inc_level()

    def end_class(self, class_name):
        self.indenter.write("""\

// Die() is called by the destructor.
MOCK_METHOD0(Die, void());

// Separately compiled constructor and destructor
TNaggyMock{n}();
virtual ~TNaggyMock{n}(){dt};

bool EnableDestructorMocking; // Set to true to make destructor call Die().\
""".format(n=class_name,
           p=self.class_prefix,
           dt=self.destructor_throw_clauses[-1]))
        self.cpp_indenter.write("""\

{ns}::TNaggyMock{n}()
  : EnableDestructorMocking(false)
{{
  // Intentionally empty
}}

{ns}::~TNaggyMock{n}(){dt}
{{
  if (EnableDestructorMocking) {{
    // Only call Die() when wanted. This reduces log spam.
    Die();
  }}
}}""".format(n=class_name,
             ns="::".join(self.namespaces),
             dt=self.destructor_throw_clauses[-1]))

        self.namespaces.pop()
        self.destructor_throw_clauses.pop()
        self.indenter.dec_level()
        self.indenter.write("};\n")
        self.indenter.write("""\
typedef testing::NiceMock<TNaggyMock{n}> TNiceMock{n};
typedef testing::StrictMock<TNaggyMock{n}> TStrictMock{n};
typedef TNiceMock{n} TMock{n};
""".format(n=class_name))

    def write_header_method(self, return_type, name, args, qualifiers):
        args = args.strip()
        qualifiers = qualifiers.strip()
        mock_method = "MOCK_"
        throw_specifier = ""
        if "const" in qualifiers:
            mock_method += "CONST_"
        if "throw" in qualifiers:
            mock_method += "THROW_"
            throw_specifier = re.sub(r"\s*const\s*", "", qualifiers)
        mock_method += "METHOD"

        # Remove default arguments
        args = re.sub(r"\s*=.+?(,|$)", "\\1", args)

        if args:
            n = len(args.split(","))
            if n > MAX_METHOD_ARGUMENTS:
                raise MockError(
                    "Method %s has %d arguments, but at most %d is supported"
                    % (name, n, MAX_METHOD_ARGUMENTS))
            mock_method += str(n)
        else:
            mock_method += "0"

        t = ""
        if throw_specifier != "":
            t = ", " + throw_specifier

        self.indenter.write("%s(%s, %s(%s)%s);"
                            % (mock_method, name, return_type, args, t))

    def generate_class(self, reader, class_name, inherits, includes,
                       restriction):
        if not restriction:
            self.begin_class(class_name)
        self.generate_methods(reader, includes, restriction)
        self.generate_inherits(inherits, includes)
        if not restriction:
            self.end_class(class_name)
            self.generated_methods_for_class = set()

    def generate_inherits(self, inherits, includes):
        for name in inherits:
            self.indenter.write("\n// " + name)
            path = self.find_include_file_for_class(includes, name)
            self.base_class_headers.add(path)
            self.generate_interface(path, name)

    def find_class(self, reader, includes, restriction):
        namespaces = []
        while reader.has_lines():
            line = reader.get_line()
            m = self.class_re.match(line)
            if m and (not restriction
                      or restriction[1:] == m.group("class")):
                inherits = self.class_re2.findall(line)
                self.generate_class(reader, m.group("class"),
                                    inherits, includes,
                                    restriction)
            m = re.match(r"\s*namespace\s+(?P<namespace>.*?)\s+", line)
            if m and not restriction:
                namespace = m.group("namespace")
                self.namespaces.append(namespace)
                namespaces.append(namespace)
                self.indenter.write("namespace " + namespace + " {\n")
        while namespaces:
            self.indenter.write("} // namespace " + namespaces[-1] + "\n")
            namespaces.pop()
            self.namespaces.pop()

    def generate_methods(self, reader, includes, restriction):
        scope_open = 0

        while reader.has_lines():
            line = reader.get_line()
            c = self.class_re.match(line)
            if c:
                inherits = self.class_re2.findall(line)
                self.generate_class(reader, c.group("class"), inherits,
                                    includes, restriction)
                continue

            m = self.destructor_re.match(line)
            if m and m.group("throw"):
                self.destructor_throw_clauses[-1] = m.group("throw")
            if self.class_prefix == "T":
                m = self.concrete_method_re.match(line)
                if m and m.group("returnType") == "explicit":
                    # Don't mock explicit constructors.
                    m = None
            else:
                m = self.method_re.match(line)
            if m:
                md = m.groupdict()
                method_signature = (md["returnType"], md["name"],
                                    md["arguments"], md["qualifiers"])
                if method_signature not in self.generated_methods_for_class:
                    self.write_header_method(*method_signature)
                    self.generated_methods_for_class.add(method_signature)

            if re.match(r"{", line):
                scope_open += 1

            if re.match(r"};?", line):
                scope_open -= 1
                if scope_open == 0:
                    return
                elif scope_open < 0:
                    raise MockError("Unbalanced braces")

    def generate_interface(self, interface_file, restriction):
        file = open(interface_file)

        includes = set()

        # Normalize code for parsing by removing preprocessor directives,
        # comments, some whitespace and other uninteresting parts.
        code = ""
        access_specifier = ""
        for line in file:
            if re.match(r"^\s*#", line):
                m = re.match(r'^\s*#include\s+["<](?P<include_file>.+?)[">]',
                             line)
                if m:
                    includes.add(m.group("include_file"))
                continue
            m = re.match(
                r"\s*(?P<access_specifier>private|protected|public):\s*$",
                line)
            if m:
                access_specifier = m.group("access_specifier")
                continue
            if access_specifier == "private":
                continue
            line = re.sub(r"//.*", "", line)
            code = code + line

        code = re.sub(r"\s+", " ", code)
        code = re.sub(r"/\*.*?\*/", "", code)
        code = re.sub(r"({|};?)", "\n\\1\n", code)
        code = re.sub(r"(;)", "\\1\n", code)
        code = re.sub(r"__attribute__\s*\(\(([^()]*|[^(]*\([^)]*\))\)\)", "",
                      code)
        code = re.sub(r"\(\s*void\s*\)", "()", code)

        code_lines = code.split("\n")

        r = LineReader(code_lines)

        self.find_class(r, includes, restriction)


class LineReader:
    def __init__(self, lines):
        self.pos = 0
        self.lines = lines

    def has_lines(self):
        return self.pos < len(self.lines)

    def get_line(self):
        l = self.lines[self.pos]
        self.pos += 1
        return l


class Indenter:
    def __init__(self, out):
        self.level = 0
        self.out = out

    def inc_level(self):
        self.level += 1

    def dec_level(self):
        self.level -= 1

    def write(self, string):
        indent = "  " * self.level
        for s in string.split("\n"):
            if s == "":
                self.out.write("\n")
            else:
                self.out.write(indent + s + "\n")


def main():
    (h_type, interface_path, interface_file, h_file, dist_path,
     dependency_file) = sys.argv[1:7]

    assert h_type in ["local", "disted"]

    if not os.path.exists(interface_file):
        raise MockError("File does not exist: " + interface_file)

    cpp_file = h_file.replace(".h", ".cpp")
    tmp_h_file = h_file + ".tmp"
    tmp_cpp_file = cpp_file + ".tmp"
    MockGenerator(h_type, interface_path, interface_file, dist_path,
                  tmp_h_file, tmp_cpp_file, h_file, dependency_file)
    os.rename(tmp_cpp_file, cpp_file)
    # Rename .h file last since it's used as a build stamp:
    os.rename(tmp_h_file, h_file)


try:
    main()
except MockError as e:
    sys.stderr.write(
        "{0}: error: Failed to create mock for {1}: {2}\n".format(
            sys.argv[0], sys.argv[3], e))
    sys.exit(1)
